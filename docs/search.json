[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BAN430 Forecasting",
    "section": "",
    "text": "In this course you will learn about forecasting methods.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWeek number\nSubject\nReading material\nFirst lecture\nSecond lecture\n\n\n\n\n2\nIntroduction and R\nChapter 1\nIntroduction lecture BAN430\nBasic R / recap\n\n\n3\nTime series graphics\nChapter 2\nGraphics\n\n\n\n4\nTime series decomposition\nChapter 3\nTime series decomposition\n\n\n\n5\nTime series features\nChapter 4\nTime series features\n\n\n\n6\nForecasters toolbox\nChapter 5\nForecasters toolbox\n\n\n\n7\nJudgmental forecasts\nChapter 6\nJudgmental forecasts\n\n\n\n8\nRegression models\nChapter 7\nRegression models\n\n\n\n9\nARIMA models\nChapter 9\nARIMA models\n\n\n\n10\nARIMA models\nChapter 9\n\n\n\n\n11\nVolatility forecasting\nCourse website\n\n\n\n\n12\nSome practicle forecasting issues\nChapter 13\n\n\n\n\n13\nPreparations for the exam\n\nDiscussion lecture/exercise seminar\n\n\n\n14\nHome exam\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFPP Third edition\n\n\nWe will use the textbook by Hyndman and Athanasopoulos (2018), i.e. the online version which can be accessed at https://otexts.com/fpp3/.\n\n\n\nTextbook (Hyndman and Athanasopoulos (2018)) chapters 1-9 and 13. Additional notes by lecturer on volatility forecasting. All the material on this website.\n\n\n\n\nHyndman, Rob J, and George Athanasopoulos. 2018. Forecasting: Principles and Practice. OTexts. https://otexts.com/fpp3/."
  },
  {
    "objectID": "1_randrstudio.html",
    "href": "1_randrstudio.html",
    "title": "1  R and Rstudio",
    "section": "",
    "text": "In this course, we will be using R and Rstudio to e.g. visualize time series, estimate model parameters, forecast, etc. It is therefore essential to have some basic knowledge of how to write an R script and how to read in data and do some simple data manipulation for preparing the data for different time series analysis. Hopefully, most of you have some experience with R and Rstudio before. If you have, this will be a short recap, if not this will be a very short introduction covering the most basic operations."
  },
  {
    "objectID": "1_randrstudio.html#r-recap",
    "href": "1_randrstudio.html#r-recap",
    "title": "1  R and Rstudio",
    "section": "R recap",
    "text": "R recap\nIf R and Rstudio are completely new tools for you, this section will probably not be detailed enough to get you started, but fear not. There are lots of good and useful online material for learning basic R. One possibility is to work through the first section of (chapter 1-8) of the book R for data science by Wickham and Grolemund (2016) available online. There is also a free Coursera course on R programming, recommended by the textbook authors.\nWe will mostly be using the tidyverse approach to doing data manipulation. This is in line with what you learn in courses like BAN400 R programming for Data Science or BAN420 Introduction to R and also with what the authors of the textbook does (Hyndman and Athanasopoulos (2018)).\nSay you are given an .xlsx file (MS excel format) of daily prices of an US 10 year Treasury bond. The excel file contains several sheets with the\n\nClosing ask price (“Ask”)\nClosing bid price (“Bid”)\nClosing mid price (“Mid”)\n\nEach contains two columns: date and price. In the figure below we have taken a screen shot of the Mid sheet.\n\n\n\nUS 10-year Treasury bonds index collected from the Refinitiv Eikon data base.\n\n\nYou are interesting in reading in the closing mid price. To read in this data, you may use the following code.\n\n\n# A tibble: 6 × 2\n  date                price\n  <dttm>              <dbl>\n1 2022-08-30 00:00:00  96.9\n2 2022-08-29 00:00:00  96.9\n3 2022-08-26 00:00:00  97.6\n4 2022-08-25 00:00:00  97.6\n5 2022-08-24 00:00:00  96.9\n6 2022-08-23 00:00:00  97.4\n\n\nThe sheet argument specifies which sheet in the excel file we want to read. The read_excel function is also quite smart so it recognizes that the date column is a date and automatically format it accordingly. It is however perhaps not so useful to also include the time of the day (all is 00:00:00), so let us remove this part.\n\n\n# A tibble: 8,804 × 2\n   date       price\n   <date>     <dbl>\n 1 2022-08-30  96.9\n 2 2022-08-29  96.9\n 3 2022-08-26  97.6\n 4 2022-08-25  97.6\n 5 2022-08-24  96.9\n 6 2022-08-23  97.4\n 7 2022-08-22  97.7\n 8 2022-08-19  98.1\n 9 2022-08-18  98.8\n10 2022-08-17  98.7\n# … with 8,794 more rows\n\n\nHere I have used the mutate function. This is a function we use to either mutate an existing column or create a new one. In this case we mutated the date column transforming it to a “Date” object. We could also be intersted in adding a column for which year the observation is from.\n\n\n# A tibble: 8,804 × 3\n   date       price  year\n   <date>     <dbl> <dbl>\n 1 2022-08-30  96.9  2022\n 2 2022-08-29  96.9  2022\n 3 2022-08-26  97.6  2022\n 4 2022-08-25  97.6  2022\n 5 2022-08-24  96.9  2022\n 6 2022-08-23  97.4  2022\n 7 2022-08-22  97.7  2022\n 8 2022-08-19  98.1  2022\n 9 2022-08-18  98.8  2022\n10 2022-08-17  98.7  2022\n# … with 8,794 more rows\n\n\nHere we have used the year function from the lubridate package, which is loaded with the fpp3 package. The operator %>% is used to add operations to the data manipulation pipeline in the given order. We start with the data object (a tibble) and add a mutate operation to that where we first transform the date column and add a year column. Now that we are pleased with our pipeline, let us save this to the dat object.\n\n\nRows: 8,804\nColumns: 3\n$ date  <date> 2022-08-30, 2022-08-29, 2022-08-26, 2022-08-25, 2022-08-24, 202…\n$ price <dbl> 96.92969, 96.92188, 97.62500, 97.60156, 96.94531, 97.38281, 97.6…\n$ year  <dbl> 2022, 2022, 2022, 2022, 2022, 2022, 2022, 2022, 2022, 2022, 2022…\n\n\nThe glimpse function summarizes the tibble/data frame.\n\nfilter and select\nNow, the data ranges from/to\n\n\n[1] \"1987-08-03\" \"2022-08-30\"\n\n\nbut say you only want to use data from 2010 onwards. To do this, we use the filter function. This function is useful for selecting rows that fulfil some condition, in this case year >= 2010. Let us make a pipeline for this\n\n\n# A tibble: 3,178 × 3\n   date       price  year\n   <date>     <dbl> <dbl>\n 1 2022-08-30  96.9  2022\n 2 2022-08-29  96.9  2022\n 3 2022-08-26  97.6  2022\n 4 2022-08-25  97.6  2022\n 5 2022-08-24  96.9  2022\n 6 2022-08-23  97.4  2022\n 7 2022-08-22  97.7  2022\n 8 2022-08-19  98.1  2022\n 9 2022-08-18  98.8  2022\n10 2022-08-17  98.7  2022\n# … with 3,168 more rows\n\n\nSince 2022 is not a complete year (in the data), you also don’t want observations after 2021. Then you can add this as an extra condition.\n\n\n# A tibble: 3,012 × 3\n   date       price  year\n   <date>     <dbl> <dbl>\n 1 2021-12-31  98.8  2021\n 2 2021-12-30  98.8  2021\n 3 2021-12-29  98.4  2021\n 4 2021-12-28  99.0  2021\n 5 2021-12-27  99.1  2021\n 6 2021-12-23  98.9  2021\n 7 2021-12-22  99.3  2021\n 8 2021-12-21  99.2  2021\n 9 2021-12-20  99.5  2021\n10 2021-12-17  99.7  2021\n# … with 3,002 more rows\n\n\nAlternatively, you can use the between function\n\n\n\nwhich will produce the same result. Another useful function is called select. While filter is used on the rows of your data, select is for columns. Say we don’t need the year column after having filtered out the years we don’t want. We can then either select the columns we want to keep\n\n\n\nor remove the columns we do not want\n\n\n# A tibble: 3,012 × 2\n   date       price\n   <date>     <dbl>\n 1 2021-12-31  98.8\n 2 2021-12-30  98.8\n 3 2021-12-29  98.4\n 4 2021-12-28  99.0\n 5 2021-12-27  99.1\n 6 2021-12-23  98.9\n 7 2021-12-22  99.3\n 8 2021-12-21  99.2\n 9 2021-12-20  99.5\n10 2021-12-17  99.7\n# … with 3,002 more rows\n\n\n\n\ngroup_by and summarize\nSay we are interested in calculating the yearly mean price. In the tidyverse pipeline this means we want to group our observations according to year and summarize by year the mean of the observations. We will filter to avoid having the first and last years that are incomplete.\n\n\n# A tibble: 34 × 2\n    year meanPrice\n   <dbl>     <dbl>\n 1  1988      99.7\n 2  1989     101. \n 3  1990     100. \n 4  1991     100. \n 5  1992     100. \n 6  1993     102. \n 7  1994      98.3\n 8  1995     102. \n 9  1996      99.8\n10  1997      99.9\n# … with 24 more rows\n\n\nThis pipeline could be read as first we take out observations prior to 1988 and after 2021, then we group the observations according to year and summarize the mean price by year. Note that this operation will delete any columns that are not in the group_by or being calculated in the summarize.\n\n\nggplot\nPlotting a data frame is convenient to do using the ggplot2 package. This will (when used appropriately) produce beautiful figures. Let us plot the time series at hand. The ggplot2 follows the same logic with a pipeline, but instead of the %>% operator, we add elements to the figure using +. We need to specify the data object and the name of the x and y columns to be plotted. Everything in the figure that is to vary based on values in the data frame needs to be wrapped in a aes (aesthetic) function (here the x and y arguments). By adding the geom_line() we insert a line.\n\n\n\n\n\nWe could instead add geom_point()\n\n\n\n\n\nor do both\n\n\n\n\n\nWe can change the colors and decrease the size of the points:\n\n\n\n\n\nOr maybe we do not want to use the default theme: –>\n\n\n\n\n\nWe can also include the plotting in our data manipulation pipeline. For instance, lets summarize the data by year and plot the resulting yearly time series.\n\n\n\n\n\n\n\nEpilogue\nWe cannot illustrate all aspects here, but you will learn new elements by studying examples throughout the course. This recap is mostly for remembering the basics of data manipulation in R and simple plotting. As you will see in the continuation, the coding is not much more complex then what you have seen here and the fpp3 package uses the same type of logic and syntax as the tidyverse. There will however be some new functions specific for time series analysis that you will need to learn.\n\n\nExercises\n\nSet working directory.\nLoad the data.\nFilter away observations prior to 2010.\nRemove columns except .. and time\nSummarize data to monthly means\nMake a plot with time on x-axis and monthly means on y-axis\nSave the figure to file.\n\n\n\n\n\nHyndman, Rob J, and George Athanasopoulos. 2018. Forecasting: Principles and Practice. OTexts. https://otexts.com/fpp3/.\n\n\nWickham, Hadley, and Garrett Grolemund. 2016. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. \" O’Reilly Media, Inc.\"."
  },
  {
    "objectID": "2_timeseriesgraphics.html",
    "href": "2_timeseriesgraphics.html",
    "title": "2  Time series graphics",
    "section": "",
    "text": "This is a book created from markdown and executable code."
  },
  {
    "objectID": "2_timeseriesgraphics.html#exercises",
    "href": "2_timeseriesgraphics.html#exercises",
    "title": "2  Time series graphics",
    "section": "2.1 Exercises",
    "text": "2.1 Exercises\nIs 1+1 the same as 2?\n\n\nLøsning"
  },
  {
    "objectID": "3_decomposition.html",
    "href": "3_decomposition.html",
    "title": "3  Decomposition",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "8_ARIMAmodels.html",
    "href": "8_ARIMAmodels.html",
    "title": "8  ARIMA models",
    "section": "",
    "text": "The following shiny app has been developed by Sondre Hølleland and is available at https://sholleland.shinyapps.io/ban430_shinyapps. Due to restrictions relating to available computing hours on the free shinyapps account, the app may not work. You may then copy the code below to run the shiny app locally on your own computer.\n\n\nShiny app code:\nlibrary(shiny)\nlibrary(tidyverse)\nlibrary(fpp3)\nlibrary(ggpubr)\nsbp.width <- 3\n\ntheme_set(theme_bw() + theme(panel.grid.major = element_blank(),\n                             panel.grid.minor = element_blank()))\n# Define UI for application that draws a histogram\nui <- fluidPage(\n\n    # Application title\n    titlePanel(\"ARMA models\"),\n    tabsetPanel(\n      tabPanel(\"AR(1)\", \n               \n               sidebarLayout(\n                 sidebarPanel(width = sbp.width,\n                              uiOutput(\"artext\"),\n                   sliderInput(\"arphi\",\n                               \"phi:\",\n                               min = -.99,\n                               max = .99,\n                               value = .7,\n                               step = .01),\n                   sliderInput(\"arsigma\",\n                               \"sigma:\",\n                               min = 0,\n                               max = 10,\n                               value = 1,\n                               step = .2),\n                   numericInput(\"arseed\",\n                                \"Seed:\",\n                                value = 1234,\n                                min = 0, \n                                max = 9999,\n                                step = 1),\n                   numericInput(\"arn\",\n                                \"Sample size:\",\n                                value = 500,\n                                min = 100, \n                                max = 5000,\n                                step = 100)\n                 ),\n                 \n                 # Show a plot of the generated distribution\n                 mainPanel(\n                   plotOutput(\"arPlot\", height = \"600px\")\n                 )\n               )),\n      tabPanel(\"MA(1)\",  \n               \n               sidebarLayout(\n                 sidebarPanel(width = sbp.width,\n                              uiOutput(\"matext\"),\n                   sliderInput(\"matheta\",\n                               \"theta:\",\n                               min = -1,\n                               max = 1,\n                               value = .7,\n                               step = .01),\n                   sliderInput(\"masigma\",\n                               \"sigma:\",\n                               min = 0,\n                               max = 10,\n                               value = 1,\n                               step = .2),\n                   numericInput(\"maseed\",\n                                \"Seed:\",\n                                value = 1234,\n                                min = 0, \n                                max = 9999,\n                                step = 1),\n                   numericInput(\"man\",\n                                \"Sample size:\",\n                                value = 500,\n                                min = 100, \n                                max = 5000,\n                                step = 100)\n                 ),\n                 \n                 # Show a plot of the generated distribution\n                 mainPanel(\n                   plotOutput(\"maPlot\", height = \"600px\")\n                 )\n               )),\n      tabPanel(\"ARMA(1,1)\", \n              \n               sidebarLayout(\n                 sidebarPanel(width = sbp.width,\n                              uiOutput(\"armatext\"),\n                   sliderInput(\"armaphi\",\n                               \"phi:\",\n                               min = -.99,\n                               max = .99,\n                               value = .7,\n                               step = .01),\n                   sliderInput(\"armatheta\",\n                               \"theta:\",\n                               min = -1,\n                               max = 1,\n                               value = .7,\n                               step = .01),\n                   sliderInput(\"armasigma\",\n                               \"sigma:\",\n                               min = 0,\n                               max = 10,\n                               value = 1,\n                               step = .2),\n                   numericInput(\"armaseed\",\n                                \"Seed:\",\n                                value = 1234,\n                                min = 0, \n                                max = 9999,\n                                step = 1),\n                   numericInput(\"arman\",\n                                \"Sample size:\",\n                                value = 500,\n                                min = 100, \n                                max = 5000,\n                                step = 100)\n                 ),\n                 \n                 # Show a plot of the generated distribution\n                 mainPanel(\n                   plotOutput(\"armaPlot\", height = \"600px\")\n                 )\n               ))))\n    # Sidebar with a slider input for number of bins \n   \n\n\n# Define server logic required to draw a histogram\nserver <- function(input, output) {\n    output$artext <- renderUI({\n      withMathJax(\"Model: $$Y_t=\\\\phi \\\\,Y_{t-1}+Z_t,\\\\quad Z_t\\\\sim \\\\text{i.i.d N}(0,\\\\sigma^2)$$\")\n    })\n    output$matext <- renderUI({\n      withMathJax(\"Model: $$Y_t=\\\\theta\\\\, Z_{t-1}+Z_t,\\\\quad Z_t\\\\sim \\\\text{i.i.d N}(0,\\\\sigma^2)$$\")\n    })\n    output$armatext <- renderUI({\n      withMathJax(\"Model: $$Y_t=\\\\phi\\\\, Y_{t-1}+\\\\theta \\\\,Z_{t-1}+Z_t,\\\\quad Z_t\\\\sim \\\\text{i.i.d N}(0,\\\\sigma^2)$$\")\n    })\n    output$arPlot <- renderPlot({\n      set.seed(input$arseed)\n      burnin <- 200\n      x <- rnorm(input$arn+burnin, sd = input$arsigma)\n      for(i in 2:length(x))\n        x[i] <- input$arphi*x[i-1]+rnorm(1, sd = input$arsigma)\n      df <- tsibble(x = x[burnin+1:(length(x)-burnin)],\n                    t = 1:(length(x)-burnin),\n                    index = \"t\")\n      # Theoretical acf: \n      \n      theoretical.correlations <- \n        tibble(lag = 1:29,\n               acf = ARMAacf(ar = c(input$arphi), lag.max = 29, pacf =FALSE)[-1],\n               pacf = ARMAacf(ar = c(input$arphi), lag.max = 29, pacf =TRUE))\n      # generate bins based on input$bins from ui.R\n       ggarrange(\n         df %>% autoplot() + scale_y_continuous(\"AR(1) series\")+\n           scale_x_continuous(\"Time index\", expand = c(0,0)),\n         ggarrange(df %>% ACF() %>% autoplot()+\n                     scale_x_continuous(\"Lag\", expand = c(0,0),limit=c(0.5,29.5), breaks = seq(0,30,5))+\n                     ylab(\"Sample PACF\"),\n         df %>% PACF() %>% autoplot()+\n           scale_x_continuous(\"Lag\", expand = c(0,0),limit=c(0.5,29.5), breaks = seq(0,30,5))+\n           ylab(\"Sample PACF\"), \n         theoretical.correlations %>% ggplot(aes(x=lag))+\n           geom_segment(aes(x=lag,xend=lag,y=0,yend=acf))+geom_hline(yintercept=0)+\n           scale_x_continuous(\"Lag\", expand = c(0,0),limit=c(0.5,29.5), breaks = seq(0,30,5))+\n           scale_y_continuous(\"Theoretical ACF\"),\n         theoretical.correlations %>% ggplot(aes(x=lag))+\n           geom_segment(aes(x=lag,xend=lag,y=0,yend=pacf))+geom_hline(yintercept=0)+\n           scale_x_continuous(\"Lag\", expand = c(0,0),limit=c(0.5,29.5), breaks = seq(0,30,5))+\n           scale_y_continuous(\"Theoretical PACF\"),\n         nrow = 2, ncol = 2),\n         ncol = 1, nrow = 2, heights = c(1,2))\n    })\n\n    output$maPlot <- renderPlot({\n      set.seed(input$maseed)\n      burnin <- 200\n      z <- rnorm(input$man+burnin, sd = input$masigma)\n      x <- numeric(input$man+burnin)\n      for(i in 2:length(x))\n        x[i] <- input$matheta*z[i-1]+z[i]\n      df <- tsibble(x = x[burnin+1:(length(x)-burnin)],\n                    t = 1:(length(x)-burnin),\n                    index = \"t\")\n      \n      theoretical.correlations <- \n        tibble(lag = 1:29,\n               acf = ARMAacf(ma = c(input$matheta), lag.max = 29, pacf =FALSE)[-1],\n               pacf = ARMAacf(ma = c(input$matheta), lag.max = 29, pacf =TRUE))\n      # generate bins based on input$bins from ui.R\n      ggarrange(\n        df %>% autoplot() + scale_y_continuous(\"MA(1) series\")+\n          scale_x_continuous(\"Time index\", expand = c(0,0)),\n        ggarrange(df %>% ACF() %>% autoplot()+\n                    scale_x_continuous(\"Lag\", expand = c(0,0),limit=c(0.5,29.5), breaks = seq(0,30,5))+\n                                         ylab(\"Sample ACF\"),\n                  df %>% PACF() %>% autoplot()+\n                    scale_x_continuous(\"Lag\", expand = c(0,0),limit=c(0.5,29.5), breaks = seq(0,30,5))+\n                                         ylab(\"Sample PACF\"), \n                  theoretical.correlations %>% ggplot(aes(x=lag))+\n                    geom_segment(aes(x=lag,xend=lag,y=0,yend=acf))+geom_hline(yintercept=0)+\n                    scale_x_continuous(\"Lag\", expand = c(0,0),limit=c(0.5,29.5), breaks = seq(0,30,5))+\n                    scale_y_continuous(\"Theoretical ACF\"),\n                  theoretical.correlations %>% ggplot(aes(x=lag))+\n                    geom_segment(aes(x=lag,xend=lag,y=0,yend=pacf))+geom_hline(yintercept=0)+\n                    scale_x_continuous(\"Lag\", expand = c(0,0),limit=c(0.5,29.5), breaks = seq(0,30,5))+\n                    scale_y_continuous(\"Theoretical PACF\"),\n                  nrow = 2, ncol = 2),\n        ncol = 1, nrow = 2, heights = c(1,2))\n    })\n    output$armaPlot <- renderPlot({\n      set.seed(input$armaseed)\n      burnin <- 200\n      #sdZ = sqrt(input$armasigma *(1-input$armaphi^2)/(1+2*input$armaphi*input$armatheta + input$armatheta^2))\n      z <- rnorm(input$arman+burnin, sd = input$armasigma)\n      x <- numeric(input$arman+burnin)\n      for(i in 2:length(x))\n        x[i] <- input$armaphi*x[i-1]+input$armatheta*z[i-1]+z[i]\n      df <- tsibble(x = x[burnin+1:(length(x)-burnin)],\n                    t = 1:(length(x)-burnin),\n                    index = \"t\")\n      \n      theoretical.correlations <- \n        tibble(lag = 1:29,\n               acf = ARMAacf(ar = c(input$armaphi), ma = c(input$armatheta), lag.max = 29, pacf =FALSE)[-1],\n               pacf = ARMAacf(ar = c(input$armaphi), ma = c(input$armatheta), lag.max = 29, pacf =TRUE))\n      # generate bins based on input$bins from ui.R\n      ggarrange(\n        df %>% autoplot() + scale_y_continuous(\"MA(1) series\")+\n          scale_x_continuous(\"Time index\", expand = c(0,0)),\n        ggarrange(df %>% ACF() %>% autoplot()+\n                    scale_x_continuous(\"Lag\", expand = c(0,0),limit=c(0.5,29.5), breaks = seq(0,30,5))+\n                                         ylab(\"Sample ACF\"),\n                  df %>% PACF() %>% autoplot()+\n                    scale_x_continuous(\"Lag\", expand = c(0,0),limit=c(0.5,29.5), breaks = seq(0,30,5))+\n                                         ylab(\"Sample PACF\"), \n                  theoretical.correlations %>% ggplot(aes(x=lag))+\n                    geom_segment(aes(x=lag,xend=lag,y=0,yend=acf))+geom_hline(yintercept=0)+\n                    scale_x_continuous(\"Lag\", expand = c(0,0),limit=c(0.5,29.5), breaks = seq(0,30,5))+\n                    scale_y_continuous(\"Theoretical ACF\"),\n                  theoretical.correlations %>% ggplot(aes(x=lag))+\n                    geom_segment(aes(x=lag,xend=lag,y=0,yend=pacf))+geom_hline(yintercept=0)+\n                    scale_x_continuous(\"Lag\", expand = c(0,0),limit=c(0.5,29.5), breaks = seq(0,30,5))+\n                    scale_y_continuous(\"Theoretical PACF\"),\n                  nrow = 2, ncol = 2),\n        ncol = 1, nrow = 2, heights = c(1,2))\n    })\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "10_Practicle_forecasting_issues.html",
    "href": "10_Practicle_forecasting_issues.html",
    "title": "10  Practicle forecasting issues",
    "section": "",
    "text": "[1] 3"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Hyndman, Rob J, and George Athanasopoulos. 2018. Forecasting:\nPrinciples and Practice. OTexts. https://otexts.com/fpp3/.\n\n\nWickham, Hadley, and Garrett Grolemund. 2016. R for Data Science:\nImport, Tidy, Transform, Visualize, and Model Data. \" O’Reilly\nMedia, Inc.\"."
  }
]